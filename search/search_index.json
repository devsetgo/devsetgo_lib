{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> <p>CI/CD Pipeline: </p> <p>SonarCloud:  </p>"},{"location":"#devsetgo-common-library","title":"DevSetGo Common Library","text":"<p>A set of common functions wrapped into a package, so I don't have to write the same code over and over. Oh and it makes the code more reusable.... or something like that.</p>"},{"location":"#testing","title":"Testing","text":"<p>Test on Windows and Linux. Since I work in Windows and Linux I test for issues there. Should work on MacOS, but let me know if there is an issue.</p>"},{"location":"#library-functions","title":"Library Functions","text":"<ul> <li> <p>file_functions</p> <ul> <li>CSV File Functions</li> <li>JSON File Functions</li> <li>Text File Functions</li> </ul> </li> <li> <p>Folder Functions</p> <ul> <li>Make Directory</li> <li>Remove Directory</li> <li>Last File Changed</li> <li>Directory List</li> </ul> </li> <li> <p>Calendar Functions</p> <ul> <li>Get Month</li> <li>Get Month Number</li> </ul> </li> <li> <p>Patterns</p> <ul> <li>Pattern Between Two Characters</li> </ul> </li> <li> <p>Logging</p> <ul> <li>logging configuration and interceptor</li> </ul> </li> </ul>"},{"location":"contribute/","title":"Contributing","text":"<p>Please feel to contribute to this project. Adding common functions is the intent and if you have one to add or improve an existing it is greatly appreciated.</p>"},{"location":"contribute/#ways-to-contribute","title":"Ways to Contribute!","text":"<ul> <li>Add or improve a function</li> <li>Add or improve documentation</li> <li>Add or improve Tests</li> <li>Report or fix a bug</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#install","title":"Install","text":"<pre><code>pip install devsetgo-lib\n\n# Aysync database setup\npip install devsetgo-lib[sqlite]\npip install devsetgo-lib[postgres]\n\n# Consider these experimental and untested\npip install devsetgo-lib[oracle]\npip install devsetgo-lib[mssql]\npip install devsetgo-lib[mysql]\n\n# For adding FastAPI endpoints\npip install devsetgo-lib[fastapi]\n\n# Install everything\npip install devsetgo-lib[all]\n</code></pre> <p>See documentation for more examples of library use</p>"},{"location":"release-notes/","title":"Release Notes\\n\\n","text":""},{"location":"common/calendar_functions/","title":"dsg_lib.common.calendar_functions","text":"<p>This module provides a set of functions to convert between month numbers and their corresponding names. It is part of the <code>dsg_lib.common</code> package and is used for handling and converting between month numbers and names.</p>"},{"location":"common/calendar_functions/#function-get_month","title":"Function: get_month","text":"<p>The <code>get_month</code> function takes an integer month number and returns the corresponding month name as a string.</p>"},{"location":"common/calendar_functions/#parameters","title":"Parameters","text":"<ul> <li><code>month</code> (int): An integer between 1 and 12 representing the month number.</li> </ul>"},{"location":"common/calendar_functions/#returns","title":"Returns","text":"<ul> <li><code>str</code>: The full name of the month corresponding to the input month number. If the input is not within the range of 1-12, returns \"Invalid month number\". If the input is not an integer, returns \"Invalid input, integer is required\".</li> </ul>"},{"location":"common/calendar_functions/#usage","title":"Usage","text":"<pre><code>from dsg_lib.common.calendar_functions import get_month\n\n# Get the name of the 1st month\nprint(get_month(1))  # Outputs: January\n\n# Get the name of the 12th month\nprint(get_month(12))  # Outputs: December\n\n# Try to get the name of an invalid month number\nprint(get_month(13))  # Outputs: Invalid month number\n\n# Try to get the name of a month using a non-integer\nprint(get_month('January'))  # Outputs: Invalid input, integer is required\n</code></pre>"},{"location":"common/calendar_functions/#function-get_month_number","title":"Function: get_month_number","text":"<p>The <code>get_month_number</code> function takes a month name as a string and returns the corresponding month number as an integer.</p>"},{"location":"common/calendar_functions/#parameters_1","title":"Parameters","text":"<ul> <li><code>month_name</code> (str): A string containing the full name of a month.</li> </ul>"},{"location":"common/calendar_functions/#returns_1","title":"Returns","text":"<ul> <li><code>int</code>: The month number corresponding to the input month name. If the input is not a valid month name, returns -1. If the input is not a string, returns \"Invalid input, string is required\".</li> </ul>"},{"location":"common/calendar_functions/#usage_1","title":"Usage","text":"<pre><code>from dsg_lib.common.calendar_functions import get_month_number\n\n# Get the number of the month \"January\"\nprint(get_month_number(\"January\"))  # Outputs: 1\n\n# Get the number of the month \"December\"\nprint(get_month_number(\"December\"))  # Outputs: 12\n\n# Try to get the number of an invalid month name\nprint(get_month_number(\"InvalidMonth\"))  # Outputs: -1\n\n# Try to get the number of a month using a non-string\nprint(get_month_number(1))  # Outputs: Invalid input, string is required\n</code></pre> <p>These functions are useful when you have month numbers or names and you want to convert between them in a more human-readable format. They also validate the input to ensure it's a valid month number or name.</p>"},{"location":"common/file_functions/","title":"File Functions","text":""},{"location":"common/file_functions/#todo","title":"TODO:","text":"<ul> <li>Create configuration for library to specify custom configurations</li> </ul>"},{"location":"common/file_functions/#create-sample-data","title":"Create Sample Data","text":"<p>create_sample_files(filename: str, sample_size: int)</p> <p>Pass in file name without an extension (.json or .csv) and the sample size. The function will create a CSV and JSON file with the resulting files in /data/csv and /data/json folders</p> <pre><code>from dsg_lib.file_functions import create_sample_files\n\ncreate_sample_files(filename=\"test_file\", sample_size=1000)\n</code></pre>"},{"location":"common/file_functions/#create-and-open-a-csv-file","title":"Create and open a CSV file","text":""},{"location":"common/file_functions/#save-csv","title":"Save CSV","text":"<p>save_csv(file_name=\"your-file-name.csv\", data=example_list, root_folder=\"/data\", delimiter=\",\", quotechar='\"')</p> <p>Required fields are filename and data (must be a list).</p> <p>Optional Fields:</p> <ul> <li>root_folder: By default, the root_dir is \"data\". The results will be in /data/csv folder, unless root_folder is defined.</li> <li>delimiter: Default is ',', must be a single printable character</li> <li> </li> </ul>"},{"location":"common/file_functions/#quotechar-default-is-must-be-a-single-printable-character","title":"quotechar: Default is '\"', must be a single printable character","text":""},{"location":"common/file_functions/#open-csv","title":"Open CSV","text":"<p>open_csv(file_name: str, delimit: str = None, quote_level:str=None, skip_initial_space:bool=True)</p> <p>Required filed of filename and optional delimiter field (delimit=). Quoting is set to minimal and initial spaces will be skipped (removed). Output result is a dictionary/json object.</p> <p>options - file_name: str | \"myfile.csv\" - delimit: str | example - \":\" single character only inside quotes - quote_level:str | [\"none\",\"non-numeric\",\"minimal\",\"all\"] default is minimal - skip_initial_space:bool | default is True</p> <p>See Python documentation as needed https://docs.python.org/3/library/csv.html</p> <pre><code>from dsg_lib.file_functions import save_csv, open_csv\ndata = [['num','1','2','3'],\n        [f'{i}',\"a\",\"b\",\"c\"]]\n\nsave_csv(filename=\"test.csv\", datad=data, root_folder=None, delimiter=None,  quotechar=None)\n\nresult =  open_csv(filename=\"test.csv\", quote_level=\"all\",)\nprint(result)\n</code></pre> <p>Note: Data being sent is a list of lists. Each row in a csv is a list. So construct the data in a similar fashion as such. Otherwise the data will not persist as you expect.</p> <pre><code>data = []\ncount = 1\nheader = [\"column 1\", \"column 2\", \"column 3\", \"column 4\"]\ndata.append(header)\n\nfor _ in range(10):\n    row = [\"this\", \"is\", \"row\", numb]\n    data.append(row)\n    count += 1\n</code></pre>"},{"location":"common/file_functions/#create-and-open-a-json-file","title":"Create and open a JSON file","text":"<p>save_json(filename: str, data: list, root_folder: str = None)</p> <p>Required fields are filename and data (must be a list). Optional is the root_folder. By default, the root_dir is \"data\". The results will be in /data/json folder, unless root_folder is defined.</p> <p>open_json(filename: str)</p> <p>Required filed of filename and optional delimiter field (delimit=). Quoting is set to minimal and initial spaces will be skipped (removed).</p> <pre><code>from dsg_lib.file_functions import save_json, open_json\n\njson_data = {\"name\": \"John\", \"age\": 30, \"cars\": [\"Ford\", \"BMW\", \"Fiat\"]}\n\nsave_json(filename=\"test.json\",data=json_data, root_folder=\"data\")\n\nresult = open_json(filename=\"test.json\")\nprint(result)\n</code></pre>"},{"location":"common/file_functions/#create-and-open-a-text-file","title":"Create and open a Text file","text":"<p>save_text(filename: str, data: list, root_folder: str = None)</p> <p>Required fields are filename and data (must be a list). Optional is the root_folder. By default, the root_dir is \"data\". The results will be in /data/text folder, unless root_folder is defined.</p> <p>open_text(filename: str)</p> <p>Required filed of filename and output is a string. Output result will be in /data/text folder.</p> <pre><code>from dsg_lib.file_functions import save_text, open_text\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h1&gt;My First Heading&lt;/h1&gt;\n&lt;p&gt;My first paragraph.&lt;/p&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nfile_functions.save_text(filename=\"test.html\", data=html)\n\nresult = open_text(filename=\"test.json\")\nprint(result)\n</code></pre>"},{"location":"common/file_functions/#delete-file","title":"Delete File","text":"<p>delete_file(file_name: str)</p> <p>Required fields are filename. Based on extension, the file will be removed. If the extension is other than .json or .csv, the file to removed will be removed from the data/text folder.</p> <pre><code>from dsg_lib.file_functions import delete_file\n\ndelete_file(filename=\"test.html\", data=html)\n</code></pre>"},{"location":"common/folder_functions/","title":"Folder Functions","text":"<p>==================</p>"},{"location":"common/folder_functions/#last_data_files_changed","title":"last_data_files_changed","text":"<p>==================</p> <p>This code defines a function <code>last_data_files_changed</code> which returns the last modified file's modification time and path from the given directory. If an error occurs while finding the last modified file, this function returns None for both modification time and path.</p>"},{"location":"common/folder_functions/#how-to-use","title":"How to Use","text":"<p>To use this function, you need to pass the path of the directory as an argument.</p> <pre><code>from pathlib import Path\nfrom datetime import datetime\nfrom typing import Tuple\nfrom dsg_lib.folder_functions import last_data_files_changed\n\n# provide directory path\ndirectory_path = Path(\"/path/to/directory\")\n\n# call function to get last modified file's modification time and path\nlast_modified_time, last_modified_file_path = last_data_files_changed(directory_path)\n\nif last_modified_time and last_modified_file_path:\n    print(f\"Last modified file in {directory_path} was {last_modified_file_path} modified at {last_modified_time}\")\nelse:\n    print(f\"Error occurred while finding last modified file in {directory_path}\")\n</code></pre>"},{"location":"common/folder_functions/#function-signature","title":"Function Signature","text":"<pre><code>def last_data_files_changed(directory_path: pathlib.Path) -&gt; Tuple[datetime.datetime, pathlib.Path]:\n</code></pre>"},{"location":"common/folder_functions/#input-parameters","title":"Input Parameters","text":"<ul> <li><code>directory_path</code> (pathlib.Path): The directory path to search for the last modified file.</li> </ul>"},{"location":"common/folder_functions/#output-parameters","title":"Output Parameters","text":"<ul> <li><code>Tuple[datetime.datetime, pathlib.Path]</code>: A tuple containing the last modified file's modification time and path, or (None, None) if an error occurs.</li> </ul>"},{"location":"common/folder_functions/#exceptions","title":"Exceptions","text":"<p>If any exception occurs while finding the last modified file, this function logs an error message and returns <code>(None, None)</code>.</p>"},{"location":"common/folder_functions/#example","title":"Example","text":"<pre><code># provide directory path\ndirectory_path = Path(\"/path/to/directory\")\n\n# call function to get last modified file's modification time and path\nlast_modified_time, last_modified_file_path = last_data_files_changed(directory_path)\n\nif last_modified_time and last_modified_file_path:\n    print(f\"Last modified file in {directory_path} was {last_modified_file_path} modified at {last_modified_time}\")\nelse:\n    print(f\"Error occurred while finding last modified file in {directory_path}\")\n</code></pre> <p>This example code snippet will return the last modified file's modification time and path for the given directory path. If any exception occurs, it logs an error message and returns <code>(None, None)</code>.</p> <p>===========================================</p>"},{"location":"common/folder_functions/#get_directory_list","title":"get_directory_list","text":"<p>===========================================</p> <p>This is a Python library function that returns a list of directories in a specified directory. The function takes one argument, the path to the directory to be searched. If the specified directory does not exist, the function raises a FileNotFoundError.</p> <p>To use this function, import it into your Python script, then call it with the path to the directory you want to search. The function returns a list of directories within that directory.</p>"},{"location":"common/folder_functions/#usage","title":"Usage","text":"<pre><code>from pathlib import Path\nfrom dsg_lib.folder_functions import get_directory_list\n\n# Call the function with the path to the directory you want to search\ndir_list = get_directory_list('/path/to/directory')\n\n# Print the list of directories\nprint(dir_list)\n</code></pre>"},{"location":"common/folder_functions/#arguments","title":"Arguments","text":"<ul> <li><code>file_directory</code> (str): The path to the directory to search for directories.</li> </ul>"},{"location":"common/folder_functions/#returns","title":"Returns","text":"<p>The function returns a list of directories in the specified directory.</p>"},{"location":"common/folder_functions/#raises","title":"Raises","text":"<ul> <li><code>FileNotFoundError</code>: If the specified directory does not exist.</li> </ul>"},{"location":"common/folder_functions/#examples","title":"Examples","text":"<pre><code># Import required libraries\nimport logging\nfrom pathlib import Path\nfrom get_directory_list import get_directory_list\n\n# Set the directory to search\ndirectory_path = Path.cwd().joinpath('my_directory')\n\n# Get the list of directories in the specified directory\ndirectory_list = get_directory_list(directory_path)\n\n# Print the list of directories\nprint(directory_list)\n</code></pre> <p>This will output a list of all directories in the specified directory.</p> <p>==============================================================</p>"},{"location":"common/folder_functions/#make_folder","title":"make_folder","text":"<p>==============================================================</p> <p>This is a Python library function that creates a new folder in a specified directory. The function takes one argument, the path to the directory in which to create the new folder. If the specified folder already exists, the function raises a FileExistsError. If the folder name contains invalid characters, the function raises a ValueError.</p> <p>To use this function, import it into your Python script, then call it with the path to the directory in which you want to create the new folder. The function returns a boolean value indicating whether the folder was created successfully.</p>"},{"location":"common/folder_functions/#usage_1","title":"Usage","text":"<pre><code>from pathlib import Path\nfrom dsg_lib.folder_functions import make_folder\n\n# Call the function with the path to the directory in which you want to create the new folder\nfolder_created = make_folder(Path('/path/to/directory/new_folder'))\n\n# Check if the folder was created successfully\nif folder_created:\n    print(\"Folder created successfully!\")\n</code></pre>"},{"location":"common/folder_functions/#arguments_1","title":"Arguments","text":"<ul> <li><code>file_directory</code> (pathlib.Path): The directory in which to create the new folder.</li> </ul>"},{"location":"common/folder_functions/#returns_1","title":"Returns","text":"<p>The function returns a boolean value indicating whether the folder was created successfully.</p>"},{"location":"common/folder_functions/#raises_1","title":"Raises","text":"<ul> <li><code>FileExistsError</code>: If the folder already exists.</li> <li><code>ValueError</code>: If the folder name contains invalid characters.</li> </ul>"},{"location":"common/folder_functions/#examples_1","title":"Examples","text":"<pre><code># Import required libraries\nimport logging\nfrom pathlib import Path\nfrom dsg_lib.folder_functions import make_folder\n\n# Set the directory in which to create the new folder\ndirectory_path = Path.cwd().joinpath('my_directory')\n\n# Set the name of the new folder to create\nnew_folder_name = 'new_folder'\n\n# Create the path to the new folder\nnew_folder_path = directory_path.joinpath(new_folder_name)\n\n# Create the new folder\nmake_folder(new_folder_path)\n\n# Log a message indicating that the new folder was created successfully\nlogging.info(f\"New folder created: {new_folder_path}\")\n</code></pre> <p>This will create a new folder named \"new_folder\" within the \"my_directory\" directory. If the new folder is created successfully, the function will log a message indicating that the new folder was created.</p> <p>================================================================</p>"},{"location":"common/folder_functions/#remove_folder","title":"remove_folder","text":"<p>================================================================</p> <p>This is a Python library function that removes a folder from a specified directory. The function takes one argument, the path to the directory containing the folder to be removed. If the specified directory does not exist, the function raises a FileNotFoundError. If the folder could not be removed, the function raises an OSError.</p> <p>To use this function, import it into your Python script, then call it with the path to the directory containing the folder to be removed. The function does not return any values.</p>"},{"location":"common/folder_functions/#usage_2","title":"Usage","text":"<pre><code>from dsg_lib.folder_functions import remove_folder\n\n# Call the function with the path to the directory containing the folder to be removed\nremove_folder('/path/to/directory/folder_to_remove')\n</code></pre>"},{"location":"common/folder_functions/#arguments_2","title":"Arguments","text":"<ul> <li><code>file_directory</code> (str): The directory containing the folder to be removed.</li> </ul>"},{"location":"common/folder_functions/#returns_2","title":"Returns","text":"<p>The function does not return any values.</p>"},{"location":"common/folder_functions/#raises_2","title":"Raises","text":"<ul> <li><code>FileNotFoundError</code>: If the specified directory does not exist.</li> <li><code>OSError</code>: If the folder could not be removed.</li> </ul>"},{"location":"common/folder_functions/#examples_2","title":"Examples","text":"<pre><code># Import required libraries\nimport logging\nfrom pathlib import Path\nfrom dsg_lib.folder_functions import remove_folder\n\n# Set the path to the folder to be removed\nfolder_to_remove = Path.cwd().joinpath('my_directory', 'folder_to_remove')\n\n# Remove the folder\nremove_folder(folder_to_remove)\n\n# Log a message indicating that the folder was removed successfully\nlogging.info(f\"Folder removed: {folder_to_remove}\")\n</code></pre> <p>This will remove the folder named \"folder_to_remove\" from the \"my_directory\" directory. If the folder is removed successfully, the function will log a message indicating that the folder was removed.</p>"},{"location":"common/logging/","title":"dsg_lib.common.logging_config","text":"<p>This module provides a convenient way to configure logging for your application using the <code>loguru</code> package. It includes an interceptor for standard Python logging and allows you to customize various aspects of logging.</p>"},{"location":"common/logging/#function-config_log","title":"Function: config_log","text":"<p>The <code>config_log</code> function is used to configure and set up a logger.</p>"},{"location":"common/logging/#parameters","title":"Parameters","text":"<ul> <li><code>logging_directory</code> (str, optional): Directory where logs will be stored. Default is \"log\".</li> <li><code>log_name</code> (str, optional): Name of the log file. Default is \"log.json\".</li> <li><code>logging_level</code> (str, optional): Logging level. Default is \"INFO\".</li> <li><code>log_rotation</code> (str, optional): Log rotation size. Default is \"10 MB\".</li> <li><code>log_retention</code> (str, optional): Log retention period. Default is \"30 days\".</li> <li><code>log_backtrace</code> (bool, optional): Enable backtrace. Default is False.</li> <li><code>log_format</code> (str, optional): Log format. Default is None.</li> <li><code>log_serializer</code> (bool, optional): Enable log serialization. Default is False.</li> <li><code>log_diagnose</code> (bool, optional): Enable diagnose. Default is False.</li> <li><code>app_name</code> (str, optional): Application name. Default is None.</li> <li><code>append_app_name</code> (bool, optional): Append application name to the log file name. Default is False.</li> </ul>"},{"location":"common/logging/#usage","title":"Usage","text":"<pre><code>from dsg_lib.common.logging_config import config_log\n\n# Configure the logger\nconfig_log(\n    logging_directory='logs',  # Directory where logs will be stored\n    log_name='app.log',  # Name of the log file\n    logging_level='DEBUG',  # Logging level\n    log_rotation='500 MB',  # Log rotation size\n    log_retention='10 days',  # Log retention period\n    log_backtrace=True,  # Enable backtrace\n    log_format=\"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSSSSS}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;\",  # Log format\n    log_serializer=False,  # Disable log serialization\n    log_diagnose=True,  # Enable diagnose\n    app_name='my_app',  # Application name\n    append_app_name=True  # Append application name to the log file name\n)\n\n# Now you can use the logger in your application\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.error(\"This is an error message\")\n</code></pre> <p>This will configure the logger to log all messages with level DEBUG or higher to a file named 'app.log' in the 'logs' directory. The log file will be rotated when it reaches a size of 500 MB and logs older than 10 days will be deleted. The log format is customized and the application name is appended to the log file name.</p>"},{"location":"common/regex/","title":"RegEx Functions","text":""},{"location":"common/regex/#todo","title":"TODO:","text":"<ul> <li>none</li> </ul> <p>=================</p>"},{"location":"common/regex/#pattern_between_two_char","title":"pattern_between_two_char","text":"<p>=================</p> <p>DSG_Lib.Patterns is a Python module that provides a function to search for a pattern between two characters in a given string.</p>"},{"location":"common/regex/#usage","title":"Usage","text":""},{"location":"common/regex/#pattern_between_two_chartext_string-str-left_characters-str-right_characters-str-dict","title":"<code>pattern_between_two_char(text_string: str, left_characters: str, right_characters: str) -&gt; dict</code>","text":"<p>This function searches for a pattern between two characters in a given string.</p>"},{"location":"common/regex/#parameters","title":"Parameters","text":"<ul> <li><code>text_string</code> (str): The string in which the pattern is searched.</li> <li><code>left_characters</code> (str): The left character used to specify the beginning of the pattern.</li> <li><code>right_characters</code> (str): The right character used to specify the end of the pattern.</li> </ul>"},{"location":"common/regex/#returns","title":"Returns","text":"<p>This function returns a dictionary with the following keys:</p> <ul> <li><code>found</code> (list): A list of all patterns found.</li> <li><code>matched_found</code> (int): The number of patterns found.</li> <li><code>pattern_parameters</code> (dict): A dictionary with the following keys:<ul> <li><code>left_character</code> (str): The left character used to specify the beginning of the pattern.</li> <li><code>right_character</code> (str): The right character used to specify the end of the pattern.</li> <li><code>regex_pattern</code> (str): The regular expression pattern used to find the pattern.</li> <li><code>text_string</code> (str): The string in which the pattern is searched.</li> </ul> </li> </ul> <p>If an error occurs during the search, the function returns a dictionary with the following keys:</p> <ul> <li><code>Error</code> (str): The error message.</li> <li><code>matched_found</code> (int): 0.</li> <li><code>pattern_parameters</code> (dict): A dictionary with the following keys:<ul> <li><code>left_character</code> (str): The left character used to specify the beginning of the pattern.</li> <li><code>right_character</code> (str): The right character used to specify the end of the pattern.</li> <li><code>regex_pattern</code> (str): None.</li> <li><code>text_string</code> (str): The string in which the pattern is searched.</li> </ul> </li> </ul>"},{"location":"common/regex/#example","title":"Example","text":"<pre><code>import dsg_lib.patterns as patterns\n\ntext = \"Hello &lt;world&gt;! Goodbye &lt;world&gt;!\"\nleft = \"&lt;\"\nright = \"&gt;\"\n\nresult = patterns.pattern_between_two_char(text, left, right)\n\nprint(result)\n</code></pre> <p>Output:</p> <pre><code>{\n    \"found\": [\"world\", \"world\"],\n    \"matched_found\": 2,\n    \"pattern_parameters\": {\n        \"left_character\": \"\\&lt;\",\n        \"right_character\": \"\\&gt;\",\n        \"regex_pattern\": \"\\&lt;(.+?)\\&gt;+?\",\n        \"text_string\": \"Hello \\&lt;world\\&gt;! Goodbye \\&lt;world\\&gt;!\"\n    }\n}\n</code></pre>"},{"location":"database/async_database_setup/","title":"Asynchronous Database Module","text":"<p>This module, <code>async_database.py</code>, is designed to manage asynchronous database operations using SQLAlchemy and asyncio.</p>"},{"location":"database/async_database_setup/#purpose","title":"Purpose","text":"<p>The purpose of this module is to allow your application to set up its database connections in a non-blocking manner. This is particularly useful in web applications where you want to start serving requests as soon as possible, even if the database setup is still ongoing.</p> <p>The module provides two main classes:</p> <ul> <li><code>DBConfig</code>: Manages the database configuration and creates a SQLAlchemy engine and a MetaData instance.</li> <li><code>AsyncDatabase</code>: Manages the asynchronous database operations. It uses an instance of <code>DBConfig</code> to perform these operations.</li> </ul>"},{"location":"database/async_database_setup/#how-to-use","title":"How to Use","text":"<p>To use this module, you need to create an instance of <code>DBConfig</code> with your database configuration, and then create an instance of <code>AsyncDatabase</code> with the <code>DBConfig</code> instance. Here's an example:</p> <pre><code>from async_database import DBConfig, AsyncDatabase\n\n# Create a DBConfig instance\ndb_config = DBConfig(database_url=\"sqlite:///./test.db\")\n\n# Create an AsyncDatabase instance\nasync_db = AsyncDatabase(db_config=db_config)\n</code></pre> <p>You can then use the <code>get_db_session</code> method of <code>AsyncDatabase</code> to get a new database session, and the <code>create_tables</code> method to create all tables in the database:</p> <pre><code># Get a new database session\nwith async_db.get_db_session() as session:\n    # Perform database operations with the session...\n\n# Asynchronously create all tables in the database\nawait async_db.create_tables()\n</code></pre>"},{"location":"database/async_database_setup/#dependencies","title":"Dependencies","text":"<p>This module depends on several Python packages, including:</p> <ul> <li><code>sqlalchemy</code> for the database operations.</li> <li><code>asyncio</code> for the asynchronous operations.</li> <li><code>logger</code> from the <code>dsg_lib</code> package for logging.</li> </ul>"},{"location":"database/async_database_setup/#note","title":"Note","text":"<p>This module requires careful error handling to ensure that database errors don't crash the application. It also requires a mechanism for checking the status of the database setup, and for waiting for the setup to complete when necessary.</p>"},{"location":"database/base_schema/","title":"Base Schema Module","text":"<p>This module, <code>base_schema.py</code>, is designed to provide a base schema for all database models in your application. It uses SQLAlchemy as the Object-Relational Mapping (ORM) tool.</p>"},{"location":"database/base_schema/#purpose","title":"Purpose","text":"<p>The purpose of this module is to define a base schema that can be inherited by all other database models in your application. This base schema includes common columns that are needed for most models, such as <code>pkid</code>, <code>date_created</code>, and <code>date_updated</code>.</p> <ul> <li><code>pkid</code>: A unique identifier for each record. It's a string representation of a UUID.</li> <li><code>date_created</code>: The date and time when a particular row was inserted into the table. It defaults to the current UTC time when the instance is created.</li> <li><code>date_updated</code>: The date and time when a particular row was last updated. It defaults to the current UTC time whenever the instance is updated.</li> </ul>"},{"location":"database/base_schema/#how-to-use","title":"How to Use","text":"<p>To use this module, you need to import it and then extend the <code>SchemaBase</code> class to create a new database model. Here's an example:</p> <pre><code>from base_schema import SchemaBase\nfrom sqlalchemy import Column, Integer, String\n\nclass User(SchemaBase):\n    __tablename__ = 'users'\n\n    name = Column(String, nullable=False)\n    age = Column(Integer, nullable=False)\n</code></pre> <p>In this example, the <code>User</code> model inherits from <code>SchemaBase</code>, which means it automatically includes the <code>pkid</code>, <code>date_created</code>, and <code>date_updated</code> columns. It also defines additional columns <code>name</code> and <code>age</code>.</p>"},{"location":"database/base_schema/#dependencies","title":"Dependencies","text":"<p>This module depends on several Python packages, including:</p> <ul> <li><code>datetime</code> from Python's standard library for handling date and time related tasks.</li> <li><code>uuid</code> from Python's standard library for generating unique identifiers.</li> <li><code>packaging</code> for comparing SQLAlchemy version.</li> <li><code>sqlalchemy</code> for defining database schema.</li> </ul>"},{"location":"database/base_schema/#note","title":"Note","text":"<p>This module also includes a function <code>import_sqlalchemy</code> that checks the installed version of SQLAlchemy and raises an ImportError if SQLAlchemy is not installed or if the installed version is not compatible with the minimum required version.</p>"},{"location":"database/database_configuration/","title":"Database Configuration Module","text":"<p>This module, <code>database_config.py</code>, is designed to handle asynchronous database operations using SQLAlchemy and asyncio. It contains several classes that each play a specific role in managing and interacting with the database.</p>"},{"location":"database/database_configuration/#classes","title":"Classes","text":""},{"location":"database/database_configuration/#dbconfig","title":"DBConfig","text":"<p>This class is responsible for managing the database configuration. It initializes the database configuration and creates a SQLAlchemy engine and a MetaData instance. The configuration is passed as a dictionary and includes parameters such as the database URI, pool size, and timeout settings. The class also provides a method to get a new database session.</p>"},{"location":"database/database_configuration/#attributes","title":"Attributes","text":"<ul> <li><code>config</code>: A dictionary containing the database configuration.</li> <li><code>engine</code>: The SQLAlchemy engine created with the database URI from the config.</li> <li><code>metadata</code>: The SQLAlchemy MetaData instance.</li> </ul>"},{"location":"database/database_configuration/#methods","title":"Methods","text":"<ul> <li><code>get_db_session()</code>: Returns a context manager that provides a new database session.</li> </ul>"},{"location":"database/database_configuration/#example-of-use","title":"Example of Use","text":"<pre><code>config = {\n    \"database_uri\": \"postgresql+asyncpg://user:password@localhost/dbname\",\n    \"echo\": True,\n    \"future\": True,\n    \"pool_pre_ping\": True,\n    \"pool_size\": 5,\n    \"max_overflow\": 10,\n    \"pool_recycle\": 3600,\n    \"pool_timeout\": 30,\n}\n\ndb_config = DBConfig(config)\n</code></pre> <p>This will create a new DBConfig instance with a SQLAlchemy engine configured according to the parameters in the config dictionary.</p> <ul> <li>Confirmed by testing [SQLITE, PostrgeSQL]</li> <li>To Be Tested [MySQL, Oracle, MSSQL] and should be considered experimental</li> </ul>"},{"location":"database/database_configuration/#supported-features-by-database","title":"Supported Features by Database","text":"Option SQLite PostgreSQL MySQL Oracle MSSQL echo Yes Yes Yes Yes Yes future Yes Yes Yes Yes Yes pool_pre_ping Yes Yes Yes Yes Yes pool_size No Yes Yes Yes Yes max_overflow No Yes Yes Yes Yes pool_recycle Yes Yes Yes Yes Yes pool_timeout No Yes Yes Yes Yes"},{"location":"database/database_configuration/#constants","title":"Constants","text":"<ul> <li><code>SUPPORTED_PARAMETERS</code>: A dictionary that specifies the supported parameters for different types of databases. This helps in validating the configuration parameters passed to the DBConfig class.</li> </ul>"},{"location":"database/database_configuration/#dependencies","title":"Dependencies","text":"<p>The module uses the logger from the <code>dsg_lib</code> for logging. The logging helps in tracking the flow of operations and in debugging by providing useful information about the operations being performed and any errors that occur.</p> <p>The module also uses the <code>time</code> module to work with times, the <code>contextlib</code> module for creating context managers, and the <code>typing</code> module for type hinting. It uses several components from the <code>sqlalchemy</code> package for database operations and error handling.</p>"},{"location":"database/database_configuration/#base-variable","title":"Base Variable","text":"<p>The <code>BASE</code> variable is a base class for declarative database models. It is created using the <code>declarative_base</code> function from <code>sqlalchemy.orm</code>.</p>"},{"location":"database/database_operations/","title":"DatabaseOperations Module Documentation","text":""},{"location":"database/database_operations/#purpose","title":"Purpose","text":"<p>The <code>DatabaseOperations</code> module provides a set of methods to interact with a database using SQLAlchemy's asynchronous API. It includes methods for creating, reading, updating, and deleting records in a database. It also includes methods for executing queries and handling exceptions.</p>"},{"location":"database/database_operations/#how-to-use","title":"How to Use","text":""},{"location":"database/database_operations/#initialization","title":"Initialization","text":"<p>First, you need to create an instance of the <code>DatabaseOperations</code> class. This class requires a reference to your database.</p> <pre><code>from dsg_lib.database import (\n    async_database,\n    base_schema,\n    database_config,\n    database_operations,\n)\n\n# Create a DBConfig instance\nconfig = {\n    \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"echo\": False,\n    \"future\": True,\n    \"pool_recycle\": 3600,\n}\n\ndb_config = database_config.DBConfig(config)\n# Create an AsyncDatabase instance\nasync_db = async_database.AsyncDatabase(db_config)\n\n# Create a DatabaseOperations instance\ndb_operations = database_operations.DatabaseOperations(async_db)\n</code></pre>"},{"location":"database/database_operations/#methods","title":"Methods","text":""},{"location":"database/database_operations/#get_one_recordquery","title":"<code>get_one_record(query)</code>","text":"<p>This method retrieves a single record from the database based on the provided query.</p> <pre><code># Get a single record\nrecord = await db_operations.get_one_record(query)\n</code></pre>"},{"location":"database/database_operations/#count_queryquery","title":"<code>count_query(query)</code>","text":"<p>This method executes a count query on the database and returns the count of records that match the query.</p> <pre><code># Count records\ncount = await db_operations.count_query(query)\n</code></pre>"},{"location":"database/database_operations/#read_queryquery-limit500-offset0","title":"<code>read_query(query, limit=500, offset=0)</code>","text":"<p>This method executes a fetch query on the database and returns the records that match the query.</p> <pre><code># Read records\nrecords = await db_operations.read_query(query)\n</code></pre>"},{"location":"database/database_operations/#read_multi_queryqueries-dictstr-str-limit500-offset0","title":"<code>read_multi_query(queries: Dict[str, str], limit=500, offset=0)</code>","text":"<p>This method executes multiple fetch queries on the database and returns the records that match each query.</p> <pre><code># Read multiple queries\nresults = await db_operations.read_multi_query(queries)\n</code></pre>"},{"location":"database/database_operations/#update_onetable-record_id-str-new_values-dict","title":"<code>update_one(table, record_id: str, new_values: dict)</code>","text":"<p>This method updates a single record in the database.</p> <pre><code># Update a record\nupdated_record = await db_operations.update_one(User, record_id, new_values)\n</code></pre>"},{"location":"database/database_operations/#delete_onetable-record_id-str","title":"<code>delete_one(table, record_id: str)</code>","text":"<p>This method deletes a single record from the database.</p> <pre><code># Delete a record\nresult = await db_operations.delete_one(User, record_id)\n</code></pre>"},{"location":"database/database_operations/#error-handling","title":"Error Handling","text":"<p>Each method in the <code>DatabaseOperations</code> class includes error handling. If an error occurs during the execution of a method, the method will return a dictionary with an \"error\" key and a description of the error.</p>"},{"location":"database/example/","title":"Examples","text":"<p>Here are a few examples of how to use the database functions</p>"},{"location":"database/example/#fastapi","title":"FastAPI","text":"<pre><code># -*- coding: utf-8 -*-\n\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import RedirectResponse\nfrom loguru import logger\nfrom tqdm import tqdm\n\nfrom dsg_lib import logging_config\n\nlogging_config.config_log(\n    logging_level=\"Debug\", log_serializer=False, log_name=\"log.log\"\n)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    logger.info(\"starting up\")\n    # Create the tables in the database\n    await async_db.create_tables()\n\n    create_users = True\n    if create_users:\n        await create_a_bunch_of_users(single_entry=23, many_entries=100)\n    yield\n    logger.info(\"shutting down\")\n\n\n# Create an instance of the FastAPI class\napp = FastAPI(\n    title=\"FastAPI Example\",  # The title of the API\n    description=\"This is an example of a FastAPI application using the DevSetGo Toolkit.\",  # A brief description of the API\n    version=\"0.1.0\",  # The version of the API\n    docs_url=\"/docs\",  # The URL where the API documentation will be served\n    redoc_url=\"/redoc\",  # The URL where the ReDoc documentation will be served\n    openapi_url=\"/openapi.json\",  # The URL where the OpenAPI schema will be served\n    debug=True,  # Enable debug mode\n    middleware=[],  # A list of middleware to include in the application\n    routes=[],  # A list of routes to include in the application\n    lifespan=lifespan,\n)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"\n    Root endpoint of API\n    Returns:\n        Redrects to openapi document\n    \"\"\"\n    # redirect to openapi docs\n    logger.info(\"Redirecting to OpenAPI docs\")\n    response = RedirectResponse(url=\"/docs\")\n    return response\n\nfrom sqlalchemy import Column, Delete, Select, String, Update\n\nfrom dsg_lib.database import (\n    async_database,\n    base_schema,\n    database_config,\n    database_operations,\n)\n\n# Create a DBConfig instance\nconfig = {\n    # \"database_uri\": \"postgresql+asyncpg://postgres:postgres@postgresdb/postgres\",\n    \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"echo\": False,\n    \"future\": True,\n    # \"pool_pre_ping\": True,\n    # \"pool_size\": 10,\n    # \"max_overflow\": 10,\n    \"pool_recycle\": 3600,\n    # \"pool_timeout\": 30,\n}\n\ndb_config = database_config.DBConfig(config)\n# Create an AsyncDatabase instance\nasync_db = async_database.AsyncDatabase(db_config)\n\n# Create a DatabaseOperations instance\ndb_ops = database_operations.DatabaseOperations(async_db)\n\n\n# User class inherits from SchemaBase and async_db.Base\n# This class represents the User table in the database\nclass User(base_schema.SchemaBase, async_db.Base):\n    __tablename__ = \"users\"  # Name of the table in the database\n\n    # Define the columns of the table\n    first_name = Column(String, unique=False, index=True)  # First name of the user\n    last_name = Column(String, unique=False, index=True)  # Last name of the user\n    email = Column(\n        String, unique=True, index=True, nullable=True\n    )  # Email of the user, must be unique\n\nasync def create_a_bunch_of_users(single_entry=0, many_entries=0):\n    logger.info(f\"single_entry: {single_entry}\")\n    await async_db.create_tables()\n    # Create a list to hold the user data\n\n    # Create a loop to generate user data\n\n    for i in tqdm(range(single_entry), desc=\"executing one\"):\n        value = secrets.token_hex(16)\n        user = User(\n            first_name=f\"First{value}\",\n            last_name=f\"Last{value}\",\n            email=f\"user{value}@example.com\",\n        )\n        logger.info(f\"created_users: {user}\")\n        await db_ops.create_one(user)\n\n    users = []\n    # Create a loop to generate user data\n    for i in tqdm(range(many_entries), desc=\"executing many\"):\n        value_one = secrets.token_hex(4)\n        value_two = secrets.token_hex(8)\n        user = User(\n            first_name=f\"First{value_one}{i}{value_two}\",\n            last_name=f\"Last{value_one}{i}{value_two}\",\n            email=f\"user{value_one}{i}{value_two}@example.com\",\n        )\n        logger.info(f\"created_users: {user.first_name}\")\n        users.append(user)\n\n    # Use db_ops to add the users to the database\n    await db_ops.create_many(users)\n\n\n@app.get(\"/database/get-count\")\nasync def get_count():\n    count = await db_ops.count_query(Select(User))\n    return {\"count\": count}\n\n\n# endpoint to get list of user\n@app.get(\"/database/get-all\")\nasync def get_all(offset: int = 0, limit: int = 100):\n    records = await db_ops.read_query(Select(User).offset(offset).limit(limit))\n    return {\"records\": records}\n\n\n@app.get(\"/database/get-primary-key\")\nasync def table_primary_key():\n    pk = await db_ops.get_primary_keys(User)\n    return {\"pk\": pk}\n\n\n@app.get(\"/database/get-column-details\")\nasync def table_column_details():\n    columns = await db_ops.get_columns_details(User)\n    return {\"columns\": columns}\n\n\n@app.get(\"/database/get-tables\")\nasync def table_table_details():\n    tables = await db_ops.get_table_names()\n    return {\"table_names\": tables}\n\n\n@app.get(\"/database/get-one-record\")\nasync def get_one_record(record_id: str):\n    record = await db_ops.get_one_record(Select(User).where(User.pkid == record_id))\n    return {\"record\": record}\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=5000)\n</code></pre>"},{"location":"database/example/#async-script","title":"Async Script","text":"<pre><code>#TODO: Create a script example\n</code></pre>"},{"location":"fastapi/full_library_example/","title":"Full library example","text":"<pre><code># -*- coding: utf-8 -*-\nimport logging\nimport secrets\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import RedirectResponse\nfrom loguru import logger\nfrom tqdm import tqdm\n\nfrom dsg_lib import logging_config\n\nlogging_config.config_log(\n    logging_level=\"Debug\", log_serializer=False, log_name=\"log.log\"\n)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    logger.info(\"starting up\")\n    # Create the tables in the database\n    await async_db.create_tables()\n\n    create_users = True\n    if create_users:\n        await create_a_bunch_of_users(single_entry=23, many_entries=100)\n    yield\n    logger.info(\"shutting down\")\n\n\n# Create an instance of the FastAPI class\napp = FastAPI(\n    title=\"FastAPI Example\",  # The title of the API\n    description=\"This is an example of a FastAPI application using the DevSetGo Toolkit.\",  # A brief description of the API\n    version=\"0.1.0\",  # The version of the API\n    docs_url=\"/docs\",  # The URL where the API documentation will be served\n    redoc_url=\"/redoc\",  # The URL where the ReDoc documentation will be served\n    openapi_url=\"/openapi.json\",  # The URL where the OpenAPI schema will be served\n    debug=True,  # Enable debug mode\n    middleware=[],  # A list of middleware to include in the application\n    routes=[],  # A list of routes to include in the application\n    lifespan=lifespan,\n)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"\n    Root endpoint of API\n    Returns:\n        Redrects to openapi document\n    \"\"\"\n    # redirect to openapi docs\n    logger.info(\"Redirecting to OpenAPI docs\")\n    response = RedirectResponse(url=\"/docs\")\n    return response\n\n\nfrom dsg_lib.fastapi_endpoints import (  # , system_tools_endpoints\n    system_health_endpoints,\n)\n\nconfig_health = {\n    \"enable_status_endpoint\": True,\n    \"enable_uptime_endpoint\": True,\n    \"enable_heapdump_endpoint\": True,\n}\napp.include_router(\n    system_health_endpoints.create_health_router(config=config_health),\n    prefix=\"/api/health\",\n    tags=[\"system-health\"],\n)\n\n\nfrom sqlalchemy import Column, Delete, Select, String, Update\n\nfrom dsg_lib.database import (\n    async_database,\n    base_schema,\n    database_config,\n    database_operations,\n)\n\n# Create a DBConfig instance\nconfig = {\n    # \"database_uri\": \"postgresql+asyncpg://postgres:postgres@postgresdb/postgres\",\n    \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"echo\": False,\n    \"future\": True,\n    # \"pool_pre_ping\": True,\n    # \"pool_size\": 10,\n    # \"max_overflow\": 10,\n    \"pool_recycle\": 3600,\n    # \"pool_timeout\": 30,\n}\n\ndb_config = database_config.DBConfig(config)\n# Create an AsyncDatabase instance\nasync_db = async_database.AsyncDatabase(db_config)\n\n# Create a DatabaseOperations instance\ndb_ops = database_operations.DatabaseOperations(async_db)\n\n\n# User class inherits from SchemaBase and async_db.Base\n# This class represents the User table in the database\nclass User(base_schema.SchemaBase, async_db.Base):\n    __tablename__ = \"users\"  # Name of the table in the database\n\n    # Define the columns of the table\n    first_name = Column(String, unique=False, index=True)  # First name of the user\n    last_name = Column(String, unique=False, index=True)  # Last name of the user\n    email = Column(\n        String, unique=True, index=True, nullable=True\n    )  # Email of the user, must be unique\n\n\nfrom sqlalchemy import ForeignKey, Integer\nfrom sqlalchemy.orm import relationship\n\n\nclass Address(base_schema.SchemaBase, async_db.Base):\n    __tablename__ = \"addresses\"  # Name of the table in the database\n\n    # Define the columns of the table\n    street = Column(String, unique=False, index=True)  # Street of the address\n    city = Column(String, unique=False, index=True)  # City of the address\n    zip = Column(String, unique=False, index=True)  # Zip code of the address\n\n    # Define the parent relationship to the User class\n    user_id = Column(Integer, ForeignKey(\"users.pkid\"))  # Foreign key to the User table\n    user = relationship(\n        \"User\", back_populates=\"addresses\"\n    )  # Relationship to the User class\n\n\n# Update the User class to include the child relationship to the Address class\nUser.addresses = relationship(\"Address\", order_by=Address.pkid, back_populates=\"user\")\n\n\nasync def create_a_bunch_of_users(single_entry=0, many_entries=0):\n    logger.info(f\"single_entry: {single_entry}\")\n    await async_db.create_tables()\n    # Create a list to hold the user data\n\n    # Create a loop to generate user data\n\n    for i in tqdm(range(single_entry), desc=\"executing one\"):\n        value = secrets.token_hex(16)\n        user = User(\n            first_name=f\"First{value}\",\n            last_name=f\"Last{value}\",\n            email=f\"user{value}@example.com\",\n        )\n        logger.info(f\"created_users: {user}\")\n        await db_ops.create_one(user)\n\n    users = []\n    # Create a loop to generate user data\n    for i in tqdm(range(many_entries), desc=\"executing many\"):\n        value_one = secrets.token_hex(4)\n        value_two = secrets.token_hex(8)\n        user = User(\n            first_name=f\"First{value_one}{i}{value_two}\",\n            last_name=f\"Last{value_one}{i}{value_two}\",\n            email=f\"user{value_one}{i}{value_two}@example.com\",\n        )\n        logger.info(f\"created_users: {user.first_name}\")\n        users.append(user)\n\n    # Use db_ops to add the users to the database\n    await db_ops.create_many(users)\n\n\n@app.get(\"/database/get-count\")\nasync def get_count():\n    count = await db_ops.count_query(Select(User))\n    return {\"count\": count}\n\n\n# endpoint to get list of user\n@app.get(\"/database/get-all\")\nasync def get_all(offset: int = 0, limit: int = 100):\n    records = await db_ops.read_query(Select(User).offset(offset).limit(limit))\n    return {\"records\": records}\n\n\n@app.get(\"/database/get-primary-key\")\nasync def table_primary_key():\n    pk = await db_ops.get_primary_keys(User)\n    return {\"pk\": pk}\n\n\n@app.get(\"/database/get-column-details\")\nasync def table_column_details():\n    columns = await db_ops.get_columns_details(User)\n    return {\"columns\": columns}\n\n\n@app.get(\"/database/get-tables\")\nasync def table_table_details():\n    tables = await db_ops.get_table_names()\n    return {\"table_names\": tables}\n\n\n@app.get(\"/database/get-one-record\")\nasync def get_one_record(record_id: str):\n    record = await db_ops.get_one_record(Select(User).where(User.pkid == record_id))\n    return {\"record\": record}\n</code></pre>"},{"location":"fastapi/http_codes/","title":"HTTP Codes Module","text":"<p>Welcome to the <code>dsg_lib.fastapi_endpoints.http_codes</code> module. This module is a part of the <code>dsg_lib</code> library, designed to streamline and enhance your experience with the FastAPI framework.</p> <p>The <code>http_codes</code> module provides a set of constants representing HTTP status codes. These constants are designed to be used in FastAPI endpoints, making your code more readable and maintainable by replacing hard-coded status code numbers with meaningful constant names.</p> <p>Whether you are building a simple API or a complex web application, the <code>http_codes</code> module can help you ensure that your endpoints return the correct HTTP status codes. This not only improves the clarity of your code, but also helps to ensure that your API behaves in a way that is consistent with HTTP standards.</p> <p>In the following sections, we will guide you on how to import and use this module, along with examples to illustrate its usage in various scenarios. Whether you are a beginner or an experienced developer, we hope this documentation will be a valuable resource as you work with the <code>dsg_lib.fastapi_endpoints.http_codes</code> module.</p>"},{"location":"fastapi/http_codes/#using-the-module","title":"Using the Module","text":"<p>The <code>http_codes</code> module provides constants for HTTP status codes. These constants can be used in FastAPI endpoints to set the HTTP status code of the response.</p> <p>Here are examples of how to use the <code>http_codes</code> constants in FastAPI endpoints:</p> <pre><code>from fastapi import FastAPI\nfrom dsg_lib.fastapi_endpoints import http_codes\n\napp = FastAPI()\n\n# Create your own list of codes\ncustom_response = generate_code_dict([400, 405, 500], description_only=False)\n\n\n# GET endpoint\n@app.get(\"/items/{item_id}\",responses=custom_response) # could also use http_codes.GET_CODES\nasync def read_item(item_id: int):\n    # ... get the item ...\n    return {\"item\": item, \"code\": http_codes.HTTP_200_OK}\n\n# POST endpoint\n@app.post(\"/items/\",responses=http_codes.POST_CODES)\nasync def create_item(item: Item):\n    # ... create the item ...\n    return {\"item\": item, \"code\": http_codes.HTTP_201_CREATED}\n\n# PUT endpoint\n@app.put(\"/items/{item_id}\",responses=http_codes.PUT_CODES)\nasync def update_item(item_id: int, item: Item):\n    # ... update the item ...\n    return {\"item\": item, \"code\": http_codes.HTTP_200_OK}\n\n# DELETE endpoint\n@app.delete(\"/items/{item_id}\",responses=http_codes.DELETE_CODES)\nasync def delete_item(item_id: int):\n    # ... delete the item ...\n    return {\"code\": http_codes.HTTP_204_NO_CONTENT}\n</code></pre> <p>In these examples, the <code>http_codes</code> constants are used to set the HTTP status code of the response. The <code>HTTP_200_OK</code> constant is used for successful GET and PUT requests, the <code>HTTP_201_CREATED</code> constant is used for successful POST requests, and the <code>HTTP_204_NO_CONTENT</code> constant is used for successful DELETE requests.</p> <p>Please note that you need to replace <code>Item</code> with your actual item model and implement the logic for getting, creating, updating, and deleting items.</p>"}]}