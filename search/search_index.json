{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> <p>CI/CD Pipeline: </p> <p>SonarCloud:  </p>"},{"location":"#devsetgo-common-library","title":"DevSetGo Common Library","text":"<p>A set of common functions wrapped into a package, so I don't have to write the same code over and over. Oh and it makes the code more reusable.... or something like that.</p>"},{"location":"#testing","title":"Testing","text":"<p>Test on Windows and Linux. Since I work in Windows and Linux I test for issues there. Should work on MacOS, but let me know if there is an issue.</p>"},{"location":"#library-functions","title":"Library Functions","text":"<ul> <li> <p>Common Functions</p> <ul> <li> <p>file_functions</p> <ul> <li>CSV File Functions</li> <li>JSON File Functions</li> <li>Text File Functions</li> </ul> </li> <li> <p>Folder Functions</p> <ul> <li>Make Directory</li> <li>Remove Directory</li> <li>Last File Changed</li> <li>Directory List</li> </ul> </li> <li> <p>Calendar Functions</p> <ul> <li>Get Month</li> <li>Get Month Number</li> </ul> </li> <li> <p>Patterns</p> <ul> <li>Pattern Between Two Characters</li> </ul> </li> <li> <p>Logging</p> <ul> <li>logging configuration and interceptor</li> </ul> </li> </ul> </li> <li> <p>FastAPI Endpoints</p> <ul> <li>Systems Health Endpoints<ul> <li>Status/Health, Heapdump, Uptime</li> </ul> </li> <li>HTTP Codes<ul> <li>Way to generate HTTP response codes</li> </ul> </li> </ul> </li> <li> <p>Aysnc Database</p> <ul> <li>Database Config</li> <li>Async Session</li> <li>Database Operations (CRUD)</li> </ul> </li> </ul>"},{"location":"contribute/","title":"Contributing","text":"<p>Please feel to contribute to this project. Adding common functions is the intent and if you have one to add or improve an existing it is greatly appreciated.</p>"},{"location":"contribute/#ways-to-contribute","title":"Ways to Contribute!","text":"<ul> <li>Add or improve a function</li> <li>Add or improve documentation</li> <li>Add or improve Tests</li> <li>Report or fix a bug</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#install","title":"Install","text":"<pre><code>pip install devsetgo-lib\n\n# Aysync database setup\npip install devsetgo-lib[sqlite]\npip install devsetgo-lib[postgres]\n\n# Consider these experimental and untested\npip install devsetgo-lib[oracle]\npip install devsetgo-lib[mssql]\npip install devsetgo-lib[mysql]\n\n# For adding FastAPI endpoints\npip install devsetgo-lib[fastapi]\n\n# Install everything\npip install devsetgo-lib[all]\n</code></pre> <p>See documentation for more examples of library use</p>"},{"location":"release-notes/","title":"Release Notes\\n\\n","text":""},{"location":"common/calendar_functions/","title":"dsg_lib.common.calendar_functions","text":"<p>This module provides a set of functions to convert between month numbers and their corresponding names. It is part of the <code>dsg_lib.common</code> package and is used for handling and converting between month numbers and names.</p>"},{"location":"common/calendar_functions/#function-get_month","title":"Function: get_month","text":"<p>The <code>get_month</code> function takes an integer month number and returns the corresponding month name as a string.</p>"},{"location":"common/calendar_functions/#parameters","title":"Parameters","text":"<ul> <li><code>month</code> (int): An integer between 1 and 12 representing the month number.</li> </ul>"},{"location":"common/calendar_functions/#returns","title":"Returns","text":"<ul> <li><code>str</code>: The full name of the month corresponding to the input month number. If the input is not within the range of 1-12, returns \"Invalid month number\". If the input is not an integer, returns \"Invalid input, integer is required\".</li> </ul>"},{"location":"common/calendar_functions/#usage","title":"Usage","text":"<pre><code>from dsg_lib.common.calendar_functions import get_month\n\n# Get the name of the 1st month\nprint(get_month(1))  # Outputs: January\n\n# Get the name of the 12th month\nprint(get_month(12))  # Outputs: December\n\n# Try to get the name of an invalid month number\nprint(get_month(13))  # Outputs: Invalid month number\n\n# Try to get the name of a month using a non-integer\nprint(get_month('January'))  # Outputs: Invalid input, integer is required\n</code></pre>"},{"location":"common/calendar_functions/#function-get_month_number","title":"Function: get_month_number","text":"<p>The <code>get_month_number</code> function takes a month name as a string and returns the corresponding month number as an integer.</p>"},{"location":"common/calendar_functions/#parameters_1","title":"Parameters","text":"<ul> <li><code>month_name</code> (str): A string containing the full name of a month.</li> </ul>"},{"location":"common/calendar_functions/#returns_1","title":"Returns","text":"<ul> <li><code>int</code>: The month number corresponding to the input month name. If the input is not a valid month name, returns -1. If the input is not a string, returns \"Invalid input, string is required\".</li> </ul>"},{"location":"common/calendar_functions/#usage_1","title":"Usage","text":"<pre><code>from dsg_lib.common.calendar_functions import get_month_number\n\n# Get the number of the month \"January\"\nprint(get_month_number(\"January\"))  # Outputs: 1\n\n# Get the number of the month \"December\"\nprint(get_month_number(\"December\"))  # Outputs: 12\n\n# Try to get the number of an invalid month name\nprint(get_month_number(\"InvalidMonth\"))  # Outputs: -1\n\n# Try to get the number of a month using a non-string\nprint(get_month_number(1))  # Outputs: Invalid input, string is required\n</code></pre> <p>These functions are useful when you have month numbers or names and you want to convert between them in a more human-readable format. They also validate the input to ensure it's a valid month number or name.</p>"},{"location":"common/file_functions/","title":"dsg_lib.common.file_functions","text":"<p>This module is part of the <code>dsg_lib.common</code> package. It provides functionality for saving and retrieving text data from files.</p>"},{"location":"common/file_functions/#usage","title":"Usage","text":"<p>To use the functions in this module, you need to import them from the <code>dsg_lib.common</code> package. Here's how you can do it:</p> <pre><code>from dsg_lib.common.file_functions import save_text, open_text, save_json, open_json, save_csv, open_csv\n</code></pre>"},{"location":"common/file_functions/#save_textfile_name-str-data-str-root_folder-str-none-str","title":"save_text(file_name: str, data: str, root_folder: str = None) -&gt; str","text":"<p>This function saves a string of text to a file.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The name of the file (excluding the extension).</li> <li><code>data</code> (str): The text data to be saved.</li> <li><code>root_folder</code> (str, optional): The root folder in which the file should be saved. Defaults to \"data\".</li> </ul> <p>Returns:</p> <ul> <li>str: A string indicating that the file save is complete.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import save_text\n\nsave_text('example', 'This is some example text.')\n</code></pre>"},{"location":"common/file_functions/#open_textfile_name-str-str","title":"open_text(file_name: str) -&gt; str","text":"<p>This function opens a text file and returns its contents as a string.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The name of the file to be opened.</li> </ul> <p>Returns:</p> <ul> <li>str: The contents of the file as a string.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import open_text\n\ntext = open_text('example')\nprint(text)  # Outputs: 'This is some example text.'\n</code></pre>"},{"location":"common/file_functions/#save_jsonfile_name-str-data-dict-root_folder-str-none-str","title":"save_json(file_name: str, data: dict, root_folder: str = None) -&gt; str","text":"<p>This function saves a dictionary as a JSON file.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The name of the file (excluding the extension).</li> <li><code>data</code> (dict): The dictionary to be saved.</li> <li><code>root_folder</code> (str, optional): The root folder in which the file should be saved. Defaults to \"data\".</li> </ul> <p>Returns:</p> <ul> <li>str: A string indicating that the file save is complete.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import save_json\n\ndata = {'key': 'value'}\nsave_json('example', data)\n</code></pre>"},{"location":"common/file_functions/#open_jsonfile_name-str-dict","title":"open_json(file_name: str) -&gt; dict","text":"<p>This function opens a JSON file and returns its contents as a dictionary.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The name of the file to be opened.</li> </ul> <p>Returns:</p> <ul> <li>dict: The contents of the file as a dictionary.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import open_json\n\ndata = open_json('example')\nprint(data)  # Outputs: {'key': 'value'}\n</code></pre>"},{"location":"common/file_functions/#save_csvfile_name-str-data-list-root_folder-str-none-str","title":"save_csv(file_name: str, data: list, root_folder: str = None) -&gt; str","text":"<p>This function saves a list of dictionaries as a CSV file.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The name of the file (excluding the extension).</li> <li><code>data</code> (list): The list of dictionaries to be saved.</li> <li><code>root_folder</code> (str, optional): The root folder in which the file should be saved. Defaults to \"data\".</li> </ul> <p>Returns:</p> <ul> <li>str: A string indicating that the file save is complete.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import save_csv\n\ndata = [{'column1': 'value1', 'column2': 'value2'}, {'column1': 'value3', 'column2': 'value4'}]\nsave_csv('example', data)\n</code></pre>"},{"location":"common/file_functions/#open_csvfile_name-str-list","title":"open_csv(file_name: str) -&gt; list","text":"<p>This function opens a CSV file and returns its contents as a list of dictionaries.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The name of the file to be opened.</li> </ul> <p>Returns:</p> <ul> <li>list: The contents of the file as a list of dictionaries.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import open_csv\n\ndata = open_csv('example')\nprint(data)  # Outputs: [{'column1': 'value1', 'column2': 'value2'}, {'column1': 'value3', 'column2': 'value4'}]\n</code></pre>"},{"location":"common/file_functions/#create_sample_filesfile_name-str-sample_size-int-none","title":"create_sample_files(file_name: str, sample_size: int) -&gt; None","text":"<p>This function creates sample CSV and JSON files with random data.</p> <p>Parameters:</p> <ul> <li><code>file_name</code> (str): The base name for the sample files (without extension).</li> <li><code>sample_size</code> (int): The number of rows to generate for the sample files.</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.file_functions import create_sample_files\n\ncreate_sample_files('example', 100)\n</code></pre> <p>This will create <code>example.csv</code> and <code>example.json</code> files each with 100 rows of random data.</p>"},{"location":"common/file_functions/#purpose","title":"Purpose","text":"<p>The purpose of this module is to provide a simple and efficient way to save and retrieve text data from files. It abstracts away the details of file handling, allowing you to focus on the data itself.</p>"},{"location":"common/folder_functions/","title":"dsg_lib.common.folder_functions","text":"<p>This module is part of the <code>dsg_lib.common</code> package. It provides functionality for interacting with the file system, including getting the last modified file in a directory, getting a list of directories in a specified directory, creating a new folder, and removing a folder.</p>"},{"location":"common/folder_functions/#installation","title":"Installation","text":"<p>This module is part of the <code>dsg_lib</code> package. To install the package, use pip:</p> <pre><code>pip install dsg_lib\n</code></pre>"},{"location":"common/folder_functions/#usage","title":"Usage","text":"<p>To use the functions in this module, you need to import them from the <code>dsg_lib.common.folder_functions</code> package. Here's how you can do it:</p> <pre><code>from dsg_lib.common.folder_functions import last_data_files_changed, get_directory_list, make_folder, remove_folder\n</code></pre>"},{"location":"common/folder_functions/#last_data_files_changeddirectory_path-pathlibpath-tupledatetimedatetime-pathlibpath","title":"last_data_files_changed(directory_path: pathlib.Path) -&gt; Tuple[datetime.datetime, pathlib.Path]","text":"<p>This function gets the last modified file in a directory and returns its modification time and path.</p> <p>Parameters:</p> <ul> <li><code>directory_path</code> (pathlib.Path): The directory to search for the last modified file.</li> </ul> <p>Returns:</p> <ul> <li>Tuple[datetime.datetime, pathlib.Path]: A tuple containing the modification time and path of the last modified file, or (None, None) if there was an error.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.folder_functions import last_data_files_changed\nfrom pathlib import Path\n\ndirectory_path = Path.cwd().joinpath('data/csv')\ntime_stamp, file_path = last_data_files_changed(directory_path)\n</code></pre>"},{"location":"common/folder_functions/#get_directory_listfile_directory-str-list","title":"get_directory_list(file_directory: str) -&gt; list","text":"<p>This function gets a list of directories in the specified directory.</p> <p>Parameters:</p> <ul> <li><code>file_directory</code> (str): The directory to search for directories.</li> </ul> <p>Returns:</p> <ul> <li>list: A list of directories in the specified directory.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.folder_functions import get_directory_list\n\ndirectories = get_directory_list('data/csv')\n</code></pre>"},{"location":"common/folder_functions/#make_folderfile_directory-pathlibpath-bool","title":"make_folder(file_directory: pathlib.Path) -&gt; bool","text":"<p>This function makes a folder in a specific directory.</p> <p>Parameters:</p> <ul> <li><code>file_directory</code> (pathlib.Path): The directory in which to create the new folder.</li> </ul> <p>Returns:</p> <ul> <li>bool: True if the folder was created successfully, False otherwise.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.folder_functions import make_folder\nfrom pathlib import Path\n\nfile_directory = Path.cwd().joinpath('data/new_folder')\nmake_folder(file_directory)\n</code></pre>"},{"location":"common/folder_functions/#remove_folderfile_directory-str","title":"remove_folder(file_directory: str)","text":"<p>This function removes a folder from the specified directory.</p> <p>Parameters:</p> <ul> <li><code>file_directory</code> (str): The directory containing the folder to be removed.</li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.folder_functions import remove_folder\n\nremove_folder('data/new_folder')\n</code></pre>"},{"location":"common/folder_functions/#purpose","title":"Purpose","text":"<p>The purpose of this module is to provide a simple and efficient way to interact with the file system. It abstracts away the details of file handling, allowing you to focus on your application logic.</p>"},{"location":"common/logging/","title":"dsg_lib.common.logging_config","text":"<p>This module provides a convenient way to configure logging for your application using the <code>loguru</code> package. It includes an interceptor for standard Python logging and allows you to customize various aspects of logging.</p>"},{"location":"common/logging/#function-config_log","title":"Function: config_log","text":"<p>The <code>config_log</code> function is used to configure and set up a logger.</p>"},{"location":"common/logging/#parameters","title":"Parameters","text":"<ul> <li><code>logging_directory</code> (str, optional): Directory where logs will be stored. Default is \"log\".</li> <li><code>log_name</code> (str, optional): Name of the log file. Default is \"log.json\".</li> <li><code>logging_level</code> (str, optional): Logging level. Default is \"INFO\".</li> <li><code>log_rotation</code> (str, optional): Log rotation size. Default is \"10 MB\".</li> <li><code>log_retention</code> (str, optional): Log retention period. Default is \"30 days\".</li> <li><code>log_backtrace</code> (bool, optional): Enable backtrace. Default is False.</li> <li><code>log_format</code> (str, optional): Log format. Default is None.</li> <li><code>log_serializer</code> (bool, optional): Enable log serialization. Default is False.</li> <li><code>log_diagnose</code> (bool, optional): Enable diagnose. Default is False.</li> <li><code>app_name</code> (str, optional): Application name. Default is None.</li> <li><code>append_app_name</code> (bool, optional): Append application name to the log file name. Default is False.</li> </ul>"},{"location":"common/logging/#usage","title":"Usage","text":"<pre><code>from dsg_lib.common.logging_config import config_log\n\n# Configure the logger\nconfig_log(\n    logging_directory='logs',  # Directory where logs will be stored\n    log_name='app.log',  # Name of the log file\n    logging_level='DEBUG',  # Logging level\n    log_rotation='500 MB',  # Log rotation size\n    log_retention='10 days',  # Log retention period\n    log_backtrace=True,  # Enable backtrace\n    log_format=\"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSSSSS}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;\",  # Log format\n    log_serializer=False,  # Disable log serialization\n    log_diagnose=True,  # Enable diagnose\n    app_name='my_app',  # Application name\n    append_app_name=True  # Append application name to the log file name\n)\n\n# Now you can use the logger in your application\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.error(\"This is an error message\")\n</code></pre> <p>This will configure the logger to log all messages with level DEBUG or higher to a file named 'app.log' in the 'logs' directory. The log file will be rotated when it reaches a size of 500 MB and logs older than 10 days will be deleted. The log format is customized and the application name is appended to the log file name.</p>"},{"location":"common/regex/","title":"dsg_lib.common.regex","text":"<p>This module is part of the <code>dsg_lib.common</code> package. It provides functionality for extracting patterns between two characters in a string using regular expressions.</p>"},{"location":"common/regex/#installation","title":"Installation","text":"<p>This module is part of the <code>dsg_lib</code> package. To install the package, use pip:</p> <pre><code>pip install dsg_lib\n</code></pre>"},{"location":"common/regex/#usage","title":"Usage","text":"<p>To use the function in this module, you need to import it from the <code>dsg_lib.common.regex</code> package. Here's how you can do it:</p> <pre><code>from dsg_lib.common.regex import pattern_between_two_char\n</code></pre>"},{"location":"common/regex/#pattern_between_two_chartext_string-str-left_characters-str-right_characters-str-dict","title":"pattern_between_two_char(text_string: str, left_characters: str, right_characters: str) -&gt; dict","text":"<p>This function searches for all patterns between two characters (left and right) in a given string using regular expressions.</p> <p>Parameters:</p> <ul> <li><code>text_string</code> (str): The string in which to search for patterns.</li> <li><code>left_characters</code> (str): The character(s) that appear(s) immediately to the left of the desired pattern.</li> <li><code>right_characters</code> (str): The character(s) that appear(s) immediately to the right of the desired pattern.</li> </ul> <p>Returns:</p> <ul> <li>dict: A dictionary with the following keys:<ul> <li>\"found\": a list of strings containing all patterns found.</li> <li>\"matched_found\": the number of patterns found.</li> <li>\"pattern_parameters\": a dictionary with the following keys:<ul> <li>\"left_character\": the escaped left character string used to build the regex pattern.</li> <li>\"right_character\": the escaped right character string used to build the regex pattern.</li> <li>\"regex_pattern\": the final regex pattern used for searching.</li> <li>\"text_string\": the escaped input string used for searching.</li> </ul> </li> </ul> </li> </ul> <p>Example:</p> <pre><code>from dsg_lib.common.regex import pattern_between_two_char\n\ntext = \"Hello, my name is 'John Doe' and I live in 'New York'.\"\nleft_char = \"'\"\nright_char = \"'\"\n\nresults = pattern_between_two_char(text, left_char, right_char)\n\nprint(results)\n</code></pre>"},{"location":"common/regex/#purpose","title":"Purpose","text":"<p>The purpose of this module is to provide a simple and efficient way to extract patterns between two characters in a string using regular expressions. It can be used in text processing tasks where you need to extract specific parts of a string based on surrounding characters.</p>"},{"location":"database/async_database_setup/","title":"Asynchronous Database Module","text":"<p>This module, <code>async_database.py</code>, is designed to manage asynchronous database operations using SQLAlchemy and asyncio.</p>"},{"location":"database/async_database_setup/#purpose","title":"Purpose","text":"<p>The purpose of this module is to allow your application to set up its database connections in a non-blocking manner. This is particularly useful in web applications where you want to start serving requests as soon as possible, even if the database setup is still ongoing.</p> <p>The module provides two main classes:</p> <ul> <li><code>DBConfig</code>: Manages the database configuration and creates a SQLAlchemy engine and a MetaData instance.</li> <li><code>AsyncDatabase</code>: Manages the asynchronous database operations. It uses an instance of <code>DBConfig</code> to perform these operations.</li> </ul>"},{"location":"database/async_database_setup/#how-to-use","title":"How to Use","text":"<p>To use this module, you need to create an instance of <code>DBConfig</code> with your database configuration, and then create an instance of <code>AsyncDatabase</code> with the <code>DBConfig</code> instance. Here's an example:</p> <pre><code>from async_database import DBConfig, AsyncDatabase\n\n# Create a DBConfig instance\ndb_config = DBConfig(database_url=\"sqlite:///./test.db\")\n\n# Create an AsyncDatabase instance\nasync_db = AsyncDatabase(db_config=db_config)\n</code></pre> <p>You can then use the <code>get_db_session</code> method of <code>AsyncDatabase</code> to get a new database session, and the <code>create_tables</code> method to create all tables in the database:</p> <pre><code># Get a new database session\nwith async_db.get_db_session() as session:\n    # Perform database operations with the session...\n\n# Asynchronously create all tables in the database\nawait async_db.create_tables()\n</code></pre>"},{"location":"database/async_database_setup/#dependencies","title":"Dependencies","text":"<p>This module depends on several Python packages, including:</p> <ul> <li><code>sqlalchemy</code> for the database operations.</li> <li><code>asyncio</code> for the asynchronous operations.</li> <li><code>logger</code> from the <code>dsg_lib</code> package for logging.</li> </ul>"},{"location":"database/async_database_setup/#note","title":"Note","text":"<p>This module requires careful error handling to ensure that database errors don't crash the application. It also requires a mechanism for checking the status of the database setup, and for waiting for the setup to complete when necessary.</p>"},{"location":"database/base_schema/","title":"Base Schema Module","text":"<p>This module, <code>base_schema.py</code>, is designed to provide a base schema for all database models in your application. It uses SQLAlchemy as the Object-Relational Mapping (ORM) tool.</p>"},{"location":"database/base_schema/#purpose","title":"Purpose","text":"<p>The purpose of this module is to define a base schema that can be inherited by all other database models in your application. This base schema includes common columns that are needed for most models, such as <code>pkid</code>, <code>date_created</code>, and <code>date_updated</code>.</p> <ul> <li><code>pkid</code>: A unique identifier for each record. It's a string representation of a UUID.</li> <li><code>date_created</code>: The date and time when a particular row was inserted into the table. It defaults to the current UTC time when the instance is created.</li> <li><code>date_updated</code>: The date and time when a particular row was last updated. It defaults to the current UTC time whenever the instance is updated.</li> </ul>"},{"location":"database/base_schema/#how-to-use","title":"How to Use","text":"<p>To use this module, you need to import it and then extend the <code>SchemaBase</code> class to create a new database model. Here's an example:</p> <pre><code>from base_schema import SchemaBase\nfrom sqlalchemy import Column, Integer, String\n\nclass User(SchemaBase):\n    __tablename__ = 'users'\n\n    name = Column(String, nullable=False)\n    age = Column(Integer, nullable=False)\n</code></pre> <p>In this example, the <code>User</code> model inherits from <code>SchemaBase</code>, which means it automatically includes the <code>pkid</code>, <code>date_created</code>, and <code>date_updated</code> columns. It also defines additional columns <code>name</code> and <code>age</code>.</p>"},{"location":"database/base_schema/#dependencies","title":"Dependencies","text":"<p>This module depends on several Python packages, including:</p> <ul> <li><code>datetime</code> from Python's standard library for handling date and time related tasks.</li> <li><code>uuid</code> from Python's standard library for generating unique identifiers.</li> <li><code>packaging</code> for comparing SQLAlchemy version.</li> <li><code>sqlalchemy</code> for defining database schema.</li> </ul>"},{"location":"database/base_schema/#note","title":"Note","text":"<p>This module also includes a function <code>import_sqlalchemy</code> that checks the installed version of SQLAlchemy and raises an ImportError if SQLAlchemy is not installed or if the installed version is not compatible with the minimum required version.</p>"},{"location":"database/database_configuration/","title":"Database Configuration Module","text":"<p>This module, <code>database_config.py</code>, is designed to handle asynchronous database operations using SQLAlchemy and asyncio. It contains several classes that each play a specific role in managing and interacting with the database.</p>"},{"location":"database/database_configuration/#classes","title":"Classes","text":""},{"location":"database/database_configuration/#dbconfig","title":"DBConfig","text":"<p>This class is responsible for managing the database configuration. It initializes the database configuration and creates a SQLAlchemy engine and a MetaData instance. The configuration is passed as a dictionary and includes parameters such as the database URI, pool size, and timeout settings. The class also provides a method to get a new database session.</p>"},{"location":"database/database_configuration/#attributes","title":"Attributes","text":"<ul> <li><code>config</code>: A dictionary containing the database configuration.</li> <li><code>engine</code>: The SQLAlchemy engine created with the database URI from the config.</li> <li><code>metadata</code>: The SQLAlchemy MetaData instance.</li> </ul>"},{"location":"database/database_configuration/#methods","title":"Methods","text":"<ul> <li><code>get_db_session()</code>: Returns a context manager that provides a new database session.</li> </ul>"},{"location":"database/database_configuration/#example-of-use","title":"Example of Use","text":"<pre><code>config = {\n    \"database_uri\": \"postgresql+asyncpg://user:password@localhost/dbname\",\n    \"echo\": True,\n    \"future\": True,\n    \"pool_pre_ping\": True,\n    \"pool_size\": 5,\n    \"max_overflow\": 10,\n    \"pool_recycle\": 3600,\n    \"pool_timeout\": 30,\n}\n\ndb_config = DBConfig(config)\n</code></pre> <p>This will create a new DBConfig instance with a SQLAlchemy engine configured according to the parameters in the config dictionary.</p> <ul> <li>Confirmed by testing [SQLITE, PostrgeSQL]</li> <li>To Be Tested [MySQL, Oracle, MSSQL] and should be considered experimental</li> </ul>"},{"location":"database/database_configuration/#supported-features-by-database","title":"Supported Features by Database","text":"Option SQLite PostgreSQL MySQL Oracle MSSQL echo Yes Yes Yes Yes Yes future Yes Yes Yes Yes Yes pool_pre_ping Yes Yes Yes Yes Yes pool_size No Yes Yes Yes Yes max_overflow No Yes Yes Yes Yes pool_recycle Yes Yes Yes Yes Yes pool_timeout No Yes Yes Yes Yes"},{"location":"database/database_configuration/#constants","title":"Constants","text":"<ul> <li><code>SUPPORTED_PARAMETERS</code>: A dictionary that specifies the supported parameters for different types of databases. This helps in validating the configuration parameters passed to the DBConfig class.</li> </ul>"},{"location":"database/database_configuration/#dependencies","title":"Dependencies","text":"<p>The module uses the logger from the <code>dsg_lib</code> for logging. The logging helps in tracking the flow of operations and in debugging by providing useful information about the operations being performed and any errors that occur.</p> <p>The module also uses the <code>time</code> module to work with times, the <code>contextlib</code> module for creating context managers, and the <code>typing</code> module for type hinting. It uses several components from the <code>sqlalchemy</code> package for database operations and error handling.</p>"},{"location":"database/database_configuration/#base-variable","title":"Base Variable","text":"<p>The <code>BASE</code> variable is a base class for declarative database models. It is created using the <code>declarative_base</code> function from <code>sqlalchemy.orm</code>.</p>"},{"location":"database/database_operations/","title":"DatabaseOperations Module Documentation","text":""},{"location":"database/database_operations/#purpose","title":"Purpose","text":"<p>The <code>DatabaseOperations</code> module provides a set of methods to interact with a database using SQLAlchemy's asynchronous API. It includes methods for creating, reading, updating, and deleting records in a database. It also includes methods for executing queries and handling exceptions.</p>"},{"location":"database/database_operations/#how-to-use","title":"How to Use","text":""},{"location":"database/database_operations/#initialization","title":"Initialization","text":"<p>First, you need to create an instance of the <code>DatabaseOperations</code> class. This class requires a reference to your database.</p> <pre><code>from dsg_lib.database import (\n    async_database,\n    base_schema,\n    database_config,\n    database_operations,\n)\n\n# Create a DBConfig instance\nconfig = {\n    \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"echo\": False,\n    \"future\": True,\n    \"pool_recycle\": 3600,\n}\n\ndb_config = database_config.DBConfig(config)\n# Create an AsyncDatabase instance\nasync_db = async_database.AsyncDatabase(db_config)\n\n# Create a DatabaseOperations instance\ndb_operations = database_operations.DatabaseOperations(async_db)\n</code></pre>"},{"location":"database/database_operations/#methods","title":"Methods","text":""},{"location":"database/database_operations/#get_one_recordquery","title":"<code>get_one_record(query)</code>","text":"<p>This method retrieves a single record from the database based on the provided query.</p> <pre><code># Get a single record\nrecord = await db_operations.get_one_record(query)\n</code></pre>"},{"location":"database/database_operations/#count_queryquery","title":"<code>count_query(query)</code>","text":"<p>This method executes a count query on the database and returns the count of records that match the query.</p> <pre><code># Count records\ncount = await db_operations.count_query(query)\n</code></pre>"},{"location":"database/database_operations/#read_queryquery-limit500-offset0","title":"<code>read_query(query, limit=500, offset=0)</code>","text":"<p>This method executes a fetch query on the database and returns the records that match the query.</p> <pre><code># Read records\nrecords = await db_operations.read_query(query)\n</code></pre>"},{"location":"database/database_operations/#read_multi_queryqueries-dictstr-str-limit500-offset0","title":"<code>read_multi_query(queries: Dict[str, str], limit=500, offset=0)</code>","text":"<p>This method executes multiple fetch queries on the database and returns the records that match each query.</p> <pre><code># Read multiple queries\nresults = await db_operations.read_multi_query(queries)\n</code></pre>"},{"location":"database/database_operations/#update_onetable-record_id-str-new_values-dict","title":"<code>update_one(table, record_id: str, new_values: dict)</code>","text":"<p>This method updates a single record in the database.</p> <pre><code># Update a record\nupdated_record = await db_operations.update_one(User, record_id, new_values)\n</code></pre>"},{"location":"database/database_operations/#delete_onetable-record_id-str","title":"<code>delete_one(table, record_id: str)</code>","text":"<p>This method deletes a single record from the database.</p> <pre><code># Delete a record\nresult = await db_operations.delete_one(User, record_id)\n</code></pre>"},{"location":"database/database_operations/#error-handling","title":"Error Handling","text":"<p>Each method in the <code>DatabaseOperations</code> class includes error handling. If an error occurs during the execution of a method, the method will return a dictionary with an \"error\" key and a description of the error.</p>"},{"location":"database/example/","title":"Examples","text":"<p>Here are a few examples of how to use the database functions</p>"},{"location":"database/example/#fastapi","title":"FastAPI","text":"<pre><code># -*- coding: utf-8 -*-\n\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import RedirectResponse\nfrom loguru import logger\nfrom tqdm import tqdm\n\nfrom dsg_lib import logging_config\n\nlogging_config.config_log(\n    logging_level=\"Debug\", log_serializer=False, log_name=\"log.log\"\n)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    logger.info(\"starting up\")\n    # Create the tables in the database\n    await async_db.create_tables()\n\n    create_users = True\n    if create_users:\n        await create_a_bunch_of_users(single_entry=23, many_entries=100)\n    yield\n    logger.info(\"shutting down\")\n\n\n# Create an instance of the FastAPI class\napp = FastAPI(\n    title=\"FastAPI Example\",  # The title of the API\n    description=\"This is an example of a FastAPI application using the DevSetGo Toolkit.\",  # A brief description of the API\n    version=\"0.1.0\",  # The version of the API\n    docs_url=\"/docs\",  # The URL where the API documentation will be served\n    redoc_url=\"/redoc\",  # The URL where the ReDoc documentation will be served\n    openapi_url=\"/openapi.json\",  # The URL where the OpenAPI schema will be served\n    debug=True,  # Enable debug mode\n    middleware=[],  # A list of middleware to include in the application\n    routes=[],  # A list of routes to include in the application\n    lifespan=lifespan,\n)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"\n    Root endpoint of API\n    Returns:\n        Redrects to openapi document\n    \"\"\"\n    # redirect to openapi docs\n    logger.info(\"Redirecting to OpenAPI docs\")\n    response = RedirectResponse(url=\"/docs\")\n    return response\n\nfrom sqlalchemy import Column, Delete, Select, String, Update\n\nfrom dsg_lib.database import (\n    async_database,\n    base_schema,\n    database_config,\n    database_operations,\n)\n\n# Create a DBConfig instance\nconfig = {\n    # \"database_uri\": \"postgresql+asyncpg://postgres:postgres@postgresdb/postgres\",\n    \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"echo\": False,\n    \"future\": True,\n    # \"pool_pre_ping\": True,\n    # \"pool_size\": 10,\n    # \"max_overflow\": 10,\n    \"pool_recycle\": 3600,\n    # \"pool_timeout\": 30,\n}\n\ndb_config = database_config.DBConfig(config)\n# Create an AsyncDatabase instance\nasync_db = async_database.AsyncDatabase(db_config)\n\n# Create a DatabaseOperations instance\ndb_ops = database_operations.DatabaseOperations(async_db)\n\n\n# User class inherits from SchemaBase and async_db.Base\n# This class represents the User table in the database\nclass User(base_schema.SchemaBase, async_db.Base):\n    __tablename__ = \"users\"  # Name of the table in the database\n\n    # Define the columns of the table\n    first_name = Column(String, unique=False, index=True)  # First name of the user\n    last_name = Column(String, unique=False, index=True)  # Last name of the user\n    email = Column(\n        String, unique=True, index=True, nullable=True\n    )  # Email of the user, must be unique\n\nasync def create_a_bunch_of_users(single_entry=0, many_entries=0):\n    logger.info(f\"single_entry: {single_entry}\")\n    await async_db.create_tables()\n    # Create a list to hold the user data\n\n    # Create a loop to generate user data\n\n    for i in tqdm(range(single_entry), desc=\"executing one\"):\n        value = secrets.token_hex(16)\n        user = User(\n            first_name=f\"First{value}\",\n            last_name=f\"Last{value}\",\n            email=f\"user{value}@example.com\",\n        )\n        logger.info(f\"created_users: {user}\")\n        await db_ops.create_one(user)\n\n    users = []\n    # Create a loop to generate user data\n    for i in tqdm(range(many_entries), desc=\"executing many\"):\n        value_one = secrets.token_hex(4)\n        value_two = secrets.token_hex(8)\n        user = User(\n            first_name=f\"First{value_one}{i}{value_two}\",\n            last_name=f\"Last{value_one}{i}{value_two}\",\n            email=f\"user{value_one}{i}{value_two}@example.com\",\n        )\n        logger.info(f\"created_users: {user.first_name}\")\n        users.append(user)\n\n    # Use db_ops to add the users to the database\n    await db_ops.create_many(users)\n\n\n@app.get(\"/database/get-count\")\nasync def get_count():\n    count = await db_ops.count_query(Select(User))\n    return {\"count\": count}\n\n\n# endpoint to get list of user\n@app.get(\"/database/get-all\")\nasync def get_all(offset: int = 0, limit: int = 100):\n    records = await db_ops.read_query(Select(User).offset(offset).limit(limit))\n    return {\"records\": records}\n\n\n@app.get(\"/database/get-primary-key\")\nasync def table_primary_key():\n    pk = await db_ops.get_primary_keys(User)\n    return {\"pk\": pk}\n\n\n@app.get(\"/database/get-column-details\")\nasync def table_column_details():\n    columns = await db_ops.get_columns_details(User)\n    return {\"columns\": columns}\n\n\n@app.get(\"/database/get-tables\")\nasync def table_table_details():\n    tables = await db_ops.get_table_names()\n    return {\"table_names\": tables}\n\n\n@app.get(\"/database/get-one-record\")\nasync def get_one_record(record_id: str):\n    record = await db_ops.get_one_record(Select(User).where(User.pkid == record_id))\n    return {\"record\": record}\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=5000)\n</code></pre>"},{"location":"database/example/#async-script","title":"Async Script","text":"<pre><code>#TODO: Create a script example\n</code></pre>"},{"location":"fastapi/full_library_example/","title":"Full library example","text":"<pre><code># -*- coding: utf-8 -*-\nimport logging\nimport secrets\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import RedirectResponse\nfrom loguru import logger\nfrom tqdm import tqdm\n\nfrom dsg_lib import logging_config\n\nlogging_config.config_log(\n    logging_level=\"Debug\", log_serializer=False, log_name=\"log.log\"\n)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    logger.info(\"starting up\")\n    # Create the tables in the database\n    await async_db.create_tables()\n\n    create_users = True\n    if create_users:\n        await create_a_bunch_of_users(single_entry=23, many_entries=100)\n    yield\n    logger.info(\"shutting down\")\n\n\n# Create an instance of the FastAPI class\napp = FastAPI(\n    title=\"FastAPI Example\",  # The title of the API\n    description=\"This is an example of a FastAPI application using the DevSetGo Toolkit.\",  # A brief description of the API\n    version=\"0.1.0\",  # The version of the API\n    docs_url=\"/docs\",  # The URL where the API documentation will be served\n    redoc_url=\"/redoc\",  # The URL where the ReDoc documentation will be served\n    openapi_url=\"/openapi.json\",  # The URL where the OpenAPI schema will be served\n    debug=True,  # Enable debug mode\n    middleware=[],  # A list of middleware to include in the application\n    routes=[],  # A list of routes to include in the application\n    lifespan=lifespan,\n)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"\n    Root endpoint of API\n    Returns:\n        Redrects to openapi document\n    \"\"\"\n    # redirect to openapi docs\n    logger.info(\"Redirecting to OpenAPI docs\")\n    response = RedirectResponse(url=\"/docs\")\n    return response\n\n\nfrom dsg_lib.fastapi_endpoints import (  # , system_tools_endpoints\n    system_health_endpoints,\n)\n\nconfig_health = {\n    \"enable_status_endpoint\": True,\n    \"enable_uptime_endpoint\": True,\n    \"enable_heapdump_endpoint\": True,\n}\napp.include_router(\n    system_health_endpoints.create_health_router(config=config_health),\n    prefix=\"/api/health\",\n    tags=[\"system-health\"],\n)\n\n\nfrom sqlalchemy import Column, Delete, Select, String, Update\n\nfrom dsg_lib.database import (\n    async_database,\n    base_schema,\n    database_config,\n    database_operations,\n)\n\n# Create a DBConfig instance\nconfig = {\n    # \"database_uri\": \"postgresql+asyncpg://postgres:postgres@postgresdb/postgres\",\n    \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"echo\": False,\n    \"future\": True,\n    # \"pool_pre_ping\": True,\n    # \"pool_size\": 10,\n    # \"max_overflow\": 10,\n    \"pool_recycle\": 3600,\n    # \"pool_timeout\": 30,\n}\n\ndb_config = database_config.DBConfig(config)\n# Create an AsyncDatabase instance\nasync_db = async_database.AsyncDatabase(db_config)\n\n# Create a DatabaseOperations instance\ndb_ops = database_operations.DatabaseOperations(async_db)\n\n\n# User class inherits from SchemaBase and async_db.Base\n# This class represents the User table in the database\nclass User(base_schema.SchemaBase, async_db.Base):\n    __tablename__ = \"users\"  # Name of the table in the database\n\n    # Define the columns of the table\n    first_name = Column(String, unique=False, index=True)  # First name of the user\n    last_name = Column(String, unique=False, index=True)  # Last name of the user\n    email = Column(\n        String, unique=True, index=True, nullable=True\n    )  # Email of the user, must be unique\n\n\nfrom sqlalchemy import ForeignKey, Integer\nfrom sqlalchemy.orm import relationship\n\n\nclass Address(base_schema.SchemaBase, async_db.Base):\n    __tablename__ = \"addresses\"  # Name of the table in the database\n\n    # Define the columns of the table\n    street = Column(String, unique=False, index=True)  # Street of the address\n    city = Column(String, unique=False, index=True)  # City of the address\n    zip = Column(String, unique=False, index=True)  # Zip code of the address\n\n    # Define the parent relationship to the User class\n    user_id = Column(Integer, ForeignKey(\"users.pkid\"))  # Foreign key to the User table\n    user = relationship(\n        \"User\", back_populates=\"addresses\"\n    )  # Relationship to the User class\n\n\n# Update the User class to include the child relationship to the Address class\nUser.addresses = relationship(\"Address\", order_by=Address.pkid, back_populates=\"user\")\n\n\nasync def create_a_bunch_of_users(single_entry=0, many_entries=0):\n    logger.info(f\"single_entry: {single_entry}\")\n    await async_db.create_tables()\n    # Create a list to hold the user data\n\n    # Create a loop to generate user data\n\n    for i in tqdm(range(single_entry), desc=\"executing one\"):\n        value = secrets.token_hex(16)\n        user = User(\n            first_name=f\"First{value}\",\n            last_name=f\"Last{value}\",\n            email=f\"user{value}@example.com\",\n        )\n        logger.info(f\"created_users: {user}\")\n        await db_ops.create_one(user)\n\n    users = []\n    # Create a loop to generate user data\n    for i in tqdm(range(many_entries), desc=\"executing many\"):\n        value_one = secrets.token_hex(4)\n        value_two = secrets.token_hex(8)\n        user = User(\n            first_name=f\"First{value_one}{i}{value_two}\",\n            last_name=f\"Last{value_one}{i}{value_two}\",\n            email=f\"user{value_one}{i}{value_two}@example.com\",\n        )\n        logger.info(f\"created_users: {user.first_name}\")\n        users.append(user)\n\n    # Use db_ops to add the users to the database\n    await db_ops.create_many(users)\n\n\n@app.get(\"/database/get-count\")\nasync def get_count():\n    count = await db_ops.count_query(Select(User))\n    return {\"count\": count}\n\n\n# endpoint to get list of user\n@app.get(\"/database/get-all\")\nasync def get_all(offset: int = 0, limit: int = 100):\n    records = await db_ops.read_query(Select(User).offset(offset).limit(limit))\n    return {\"records\": records}\n\n\n@app.get(\"/database/get-primary-key\")\nasync def table_primary_key():\n    pk = await db_ops.get_primary_keys(User)\n    return {\"pk\": pk}\n\n\n@app.get(\"/database/get-column-details\")\nasync def table_column_details():\n    columns = await db_ops.get_columns_details(User)\n    return {\"columns\": columns}\n\n\n@app.get(\"/database/get-tables\")\nasync def table_table_details():\n    tables = await db_ops.get_table_names()\n    return {\"table_names\": tables}\n\n\n@app.get(\"/database/get-one-record\")\nasync def get_one_record(record_id: str):\n    record = await db_ops.get_one_record(Select(User).where(User.pkid == record_id))\n    return {\"record\": record}\n</code></pre>"},{"location":"fastapi/http_codes/","title":"HTTP Codes Module","text":"<p>Welcome to the <code>dsg_lib.fastapi_endpoints.http_codes</code> module. This module is a part of the <code>dsg_lib</code> library, designed to streamline and enhance your experience with the FastAPI framework.</p> <p>The <code>http_codes</code> module provides a set of constants representing HTTP status codes. These constants are designed to be used in FastAPI endpoints, making your code more readable and maintainable by replacing hard-coded status code numbers with meaningful constant names.</p> <p>Whether you are building a simple API or a complex web application, the <code>http_codes</code> module can help you ensure that your endpoints return the correct HTTP status codes. This not only improves the clarity of your code, but also helps to ensure that your API behaves in a way that is consistent with HTTP standards.</p> <p>In the following sections, we will guide you on how to import and use this module, along with examples to illustrate its usage in various scenarios. Whether you are a beginner or an experienced developer, we hope this documentation will be a valuable resource as you work with the <code>dsg_lib.fastapi_endpoints.http_codes</code> module.</p>"},{"location":"fastapi/http_codes/#using-the-module","title":"Using the Module","text":"<p>The <code>http_codes</code> module provides constants for HTTP status codes. These constants can be used in FastAPI endpoints to set the HTTP status code of the response.</p> <p>Here are examples of how to use the <code>http_codes</code> constants in FastAPI endpoints:</p> <pre><code>from fastapi import FastAPI\nfrom dsg_lib.fastapi_endpoints import http_codes\n\napp = FastAPI()\n\n# Create your own list of codes\ncustom_response = generate_code_dict([400, 405, 500], description_only=False)\n\n\n# GET endpoint\n@app.get(\"/items/{item_id}\",responses=custom_response) # could also use http_codes.GET_CODES\nasync def read_item(item_id: int):\n    # ... get the item ...\n    return {\"item\": item, \"code\": http_codes.HTTP_200_OK}\n\n# POST endpoint\n@app.post(\"/items/\",responses=http_codes.POST_CODES)\nasync def create_item(item: Item):\n    # ... create the item ...\n    return {\"item\": item, \"code\": http_codes.HTTP_201_CREATED}\n\n# PUT endpoint\n@app.put(\"/items/{item_id}\",responses=http_codes.PUT_CODES)\nasync def update_item(item_id: int, item: Item):\n    # ... update the item ...\n    return {\"item\": item, \"code\": http_codes.HTTP_200_OK}\n\n# DELETE endpoint\n@app.delete(\"/items/{item_id}\",responses=http_codes.DELETE_CODES)\nasync def delete_item(item_id: int):\n    # ... delete the item ...\n    return {\"code\": http_codes.HTTP_204_NO_CONTENT}\n</code></pre> <p>In these examples, the <code>http_codes</code> constants are used to set the HTTP status code of the response. The <code>HTTP_200_OK</code> constant is used for successful GET and PUT requests, the <code>HTTP_201_CREATED</code> constant is used for successful POST requests, and the <code>HTTP_204_NO_CONTENT</code> constant is used for successful DELETE requests.</p> <p>Please note that you need to replace <code>Item</code> with your actual item model and implement the logic for getting, creating, updating, and deleting items.</p>"}]}